# Plan: Add long-polling support for inbox messages

**ID:** f12c6c95
**Created:** 2026-01-24 19:55:36 UTC
**Updated:** 2026-01-24 20:11:03 UTC
**Status:** in-progress
**Approval Policy:** interactive
**Approved By:** agent
**Session:** e015b30b-1be9-4ff9-876c-bc1838897bee

## Context

## Problem
Currently, deaddrop only supports polling for new messages via `GET /{ns}/inbox/{id}`. Agents must repeatedly poll to check for new messages, which is inefficient and introduces latency.

## Goal
Add long-polling support so clients can efficiently wait for new messages without constant polling. The server holds the connection open until:
1. New messages arrive, OR
2. A timeout is reached (e.g., 30 seconds)

## Current State
- `GET /{ns}/inbox/{id}` - Returns messages immediately
- `GET /{ns}/inbox/{id}?after={mid}` - Returns messages after a cursor
- `GET /{ns}/inbox/{id}?unread=true` - Returns only unread messages
- No subscription/push mechanism exists

## Constraints
- Must work with both local and remote backends
- Must maintain backward compatibility (existing polling still works)
- Should be simple to use from the client side

## Implementation Approach

## API Design

Add a `wait` query parameter to the existing inbox endpoint:

```
GET /{ns}/inbox/{id}?wait=30
GET /{ns}/inbox/{id}?wait=30&after={mid}
GET /{ns}/inbox/{id}?wait=30&unread=true
```

- `wait=N` - Wait up to N seconds for new messages (max 60, default behavior: 0 = no wait)
- If messages exist immediately, return them right away
- If no messages, wait until messages arrive or timeout
- Returns same response format as regular inbox endpoint

## Implementation Strategy

### 1. Server-Side (API)
- Add `wait` query parameter to `get_inbox` endpoint
- Use `asyncio.sleep` in a polling loop with short intervals (e.g., 500ms)
- Check for new messages each iteration
- Return early if messages found or timeout reached
- FastAPI supports async endpoints natively

### 2. Database Layer
- Add `has_new_messages(ns, identity_id, after_mid)` function for efficient checking
- Uses lightweight COUNT query instead of fetching full messages
- Only fetch full messages when we know they exist

### 3. Client Library
- Add `wait` parameter to `get_inbox()` method
- Add convenience method `wait_for_messages()` for common patterns
- Works identically for local and remote backends

### 4. Local Backend
- LocalBackend can use the same polling approach
- In-memory check is fast, so short poll interval is fine

## Why This Approach

1. **Simple** - Reuses existing endpoint, just adds wait behavior
2. **Compatible** - Works with HTTP/1.1, no WebSocket/SSE complexity
3. **Portable** - Same API works for local, remote, and in-memory backends
4. **Resumable** - Client can always fall back to regular polling
5. **Proxy-friendly** - Standard HTTP request/response

## Tasks

- ✓✓ **Add efficient message check function to db.py** (id: f485e7a2)
  - Details: Add `has_new_messages(ns, identity_id, after_mid=None, unread_only=False)` that returns bool using COUNT query. Much lighter than fetching all messages.
  - Tests: Unit test the new function
  - Verification: 3 tests pass:
- test_has_new_messages_basic: Correctly returns False when no messages, True after sending
- test_has_new_messages_after_mid: Correctly filters by message ID cursor
- test_has_new_messages_unread_only: Correctly filters by read status

- ✓✓ **Add long-polling support to inbox API endpoint** (id: d2cfb2a3)
  - Details: Add `wait` query parameter (0-60 seconds). Use async polling loop with 500ms sleep intervals. Return early when messages found or timeout.
  - Tests: Test immediate return, timeout, and early return scenarios
  - Dependencies: f485e7a2
  - Verification: 3 API tests pass:
- test_inbox_long_poll_immediate_return: Returns immediately when messages exist (<1s)
- test_inbox_long_poll_timeout: Waits full timeout when no messages (>=0.9s for 1s wait)
- test_inbox_no_wait_returns_immediately: No wait param returns instantly (<0.5s)

- ✓✓ **Add wait support to Backend interface and implementations** (id: 07fc4ccf)
  - Details: Add `get_inbox(..., wait=0)` parameter. LocalBackend/InMemoryBackend use polling loop. RemoteBackend passes wait param to API.
  - Tests: Test wait behavior for local and in-memory backends
  - Dependencies: f485e7a2
  - Verification: 4 backend tests pass:
- test_local_wait_immediate_return: Returns immediately when messages exist
- test_local_wait_timeout: Waits full timeout when no messages
- test_in_memory_wait: Same behavior for in-memory backend
- test_wait_with_after_cursor: Respects after_mid cursor during wait

- ✓✓ **Add wait support to Deaddrop client** (id: 2ac9dedf)
  - Details: Add `wait` parameter to `get_inbox()`. Add `wait_for_messages()` convenience method that loops with long-poll.
  - Tests: Test client wait functionality
  - Dependencies: 07fc4ccf
  - Verification: 3 client tests pass:
- test_get_inbox_with_wait: get_inbox() wait parameter works
- test_wait_for_messages: Convenience method returns immediately when messages exist
- test_listen_generator: Generator yields messages correctly

- ✓✓ **Document long-polling feature** (id: 1405aa6b)
  - Details: Update README and add examples for long-polling usage in Python and CLI.
  - Dependencies: 2ac9dedf
  - Verification: Documentation added:
- README.md: New "Long-Polling" section with API and Python library examples
- README.md: Updated API reference to show ?wait=N parameter

## Considerations

_No considerations noted yet._

## Progress Log

- [2026-01-24 19:55] Plan created: Add long-polling support for inbox messages
- [2026-01-24 19:56] Updated context
- [2026-01-24 19:56] Updated approach
- [2026-01-24 19:56] Added 5 tasks
- [2026-01-24 19:57] Plan submitted for review
- [2026-01-24 19:58] Plan self-approved by agent
- [2026-01-24 19:58] Plan execution started
- [2026-01-24 19:59] Completed task f485e7a2: Added has_new_messages() function to db.py that uses COUNT query for efficient checking.
- [2026-01-24 20:00] Verified task f485e7a2
- [2026-01-24 20:03] Completed task d2cfb2a3: Added `wait` query parameter (0-60 seconds) to GET /{ns}/inbox/{id} endpoint. Uses async polling loop with 500ms intervals.
- [2026-01-24 20:03] Verified task d2cfb2a3
- [2026-01-24 20:05] Completed task 07fc4ccf: Added `wait` parameter to Backend.get_inbox() interface. LocalBackend and InMemoryBackend use time.sleep polling loop. RemoteBackend passes wait param to API with extended timeout.
- [2026-01-24 20:06] Verified task 07fc4ccf
- [2026-01-24 20:08] Completed task 2ac9dedf: Added `wait` parameter to client.get_inbox(). Added convenience methods: wait_for_messages() and listen() generator.
- [2026-01-24 20:08] Verified task 2ac9dedf
- [2026-01-24 20:10] Completed task 1405aa6b: Added Long-Polling section to README with API usage and Python library examples. Updated API reference to show wait parameter.
- [2026-01-24 20:11] Verified task 1405aa6b

---

<!-- plan-data
{
  "id": "f12c6c95",
  "title": "Add long-polling support for inbox messages",
  "status": "in-progress",
  "session_id": "e015b30b-1be9-4ff9-876c-bc1838897bee",
  "created_at": "2026-01-24T19:55:36.235593+00:00",
  "updated_at": "2026-01-24T20:11:03.279574+00:00",
  "root_dirs": [
    "/Users/seanfitz/development/deaddrop"
  ],
  "storage_location": "local",
  "pull_request": "",
  "shelved": false,
  "remote_workspace": "",
  "remote_branch": "",
  "remote_started_at": null,
  "context": "## Problem\nCurrently, deaddrop only supports polling for new messages via `GET /{ns}/inbox/{id}`. Agents must repeatedly poll to check for new messages, which is inefficient and introduces latency.\n\n## Goal\nAdd long-polling support so clients can efficiently wait for new messages without constant polling. The server holds the connection open until:\n1. New messages arrive, OR\n2. A timeout is reached (e.g., 30 seconds)\n\n## Current State\n- `GET /{ns}/inbox/{id}` - Returns messages immediately\n- `GET /{ns}/inbox/{id}?after={mid}` - Returns messages after a cursor\n- `GET /{ns}/inbox/{id}?unread=true` - Returns only unread messages\n- No subscription/push mechanism exists\n\n## Constraints\n- Must work with both local and remote backends\n- Must maintain backward compatibility (existing polling still works)\n- Should be simple to use from the client side",
  "approach": "## API Design\n\nAdd a `wait` query parameter to the existing inbox endpoint:\n\n```\nGET /{ns}/inbox/{id}?wait=30\nGET /{ns}/inbox/{id}?wait=30&after={mid}\nGET /{ns}/inbox/{id}?wait=30&unread=true\n```\n\n- `wait=N` - Wait up to N seconds for new messages (max 60, default behavior: 0 = no wait)\n- If messages exist immediately, return them right away\n- If no messages, wait until messages arrive or timeout\n- Returns same response format as regular inbox endpoint\n\n## Implementation Strategy\n\n### 1. Server-Side (API)\n- Add `wait` query parameter to `get_inbox` endpoint\n- Use `asyncio.sleep` in a polling loop with short intervals (e.g., 500ms)\n- Check for new messages each iteration\n- Return early if messages found or timeout reached\n- FastAPI supports async endpoints natively\n\n### 2. Database Layer\n- Add `has_new_messages(ns, identity_id, after_mid)` function for efficient checking\n- Uses lightweight COUNT query instead of fetching full messages\n- Only fetch full messages when we know they exist\n\n### 3. Client Library\n- Add `wait` parameter to `get_inbox()` method\n- Add convenience method `wait_for_messages()` for common patterns\n- Works identically for local and remote backends\n\n### 4. Local Backend\n- LocalBackend can use the same polling approach\n- In-memory check is fast, so short poll interval is fine\n\n## Why This Approach\n\n1. **Simple** - Reuses existing endpoint, just adds wait behavior\n2. **Compatible** - Works with HTTP/1.1, no WebSocket/SSE complexity\n3. **Portable** - Same API works for local, remote, and in-memory backends\n4. **Resumable** - Client can always fall back to regular polling\n5. **Proxy-friendly** - Standard HTTP request/response",
  "tasks": [
    {
      "id": "f485e7a2",
      "description": "Add efficient message check function to db.py",
      "details": "Add `has_new_messages(ns, identity_id, after_mid=None, unread_only=False)` that returns bool using COUNT query. Much lighter than fetching all messages.",
      "files": [],
      "tests": "Unit test the new function",
      "dependencies": [],
      "completed": true,
      "verified": true,
      "verification_notes": "3 tests pass:\n- test_has_new_messages_basic: Correctly returns False when no messages, True after sending\n- test_has_new_messages_after_mid: Correctly filters by message ID cursor\n- test_has_new_messages_unread_only: Correctly filters by read status"
    },
    {
      "id": "d2cfb2a3",
      "description": "Add long-polling support to inbox API endpoint",
      "details": "Add `wait` query parameter (0-60 seconds). Use async polling loop with 500ms sleep intervals. Return early when messages found or timeout.",
      "files": [],
      "tests": "Test immediate return, timeout, and early return scenarios",
      "dependencies": [
        "f485e7a2"
      ],
      "completed": true,
      "verified": true,
      "verification_notes": "3 API tests pass:\n- test_inbox_long_poll_immediate_return: Returns immediately when messages exist (<1s)\n- test_inbox_long_poll_timeout: Waits full timeout when no messages (>=0.9s for 1s wait)\n- test_inbox_no_wait_returns_immediately: No wait param returns instantly (<0.5s)"
    },
    {
      "id": "07fc4ccf",
      "description": "Add wait support to Backend interface and implementations",
      "details": "Add `get_inbox(..., wait=0)` parameter. LocalBackend/InMemoryBackend use polling loop. RemoteBackend passes wait param to API.",
      "files": [],
      "tests": "Test wait behavior for local and in-memory backends",
      "dependencies": [
        "f485e7a2"
      ],
      "completed": true,
      "verified": true,
      "verification_notes": "4 backend tests pass:\n- test_local_wait_immediate_return: Returns immediately when messages exist\n- test_local_wait_timeout: Waits full timeout when no messages\n- test_in_memory_wait: Same behavior for in-memory backend\n- test_wait_with_after_cursor: Respects after_mid cursor during wait"
    },
    {
      "id": "2ac9dedf",
      "description": "Add wait support to Deaddrop client",
      "details": "Add `wait` parameter to `get_inbox()`. Add `wait_for_messages()` convenience method that loops with long-poll.",
      "files": [],
      "tests": "Test client wait functionality",
      "dependencies": [
        "07fc4ccf"
      ],
      "completed": true,
      "verified": true,
      "verification_notes": "3 client tests pass:\n- test_get_inbox_with_wait: get_inbox() wait parameter works\n- test_wait_for_messages: Convenience method returns immediately when messages exist\n- test_listen_generator: Generator yields messages correctly"
    },
    {
      "id": "1405aa6b",
      "description": "Document long-polling feature",
      "details": "Update README and add examples for long-polling usage in Python and CLI.",
      "files": [],
      "tests": "",
      "dependencies": [
        "2ac9dedf"
      ],
      "completed": true,
      "verified": true,
      "verification_notes": "Documentation added:\n- README.md: New \"Long-Polling\" section with API and Python library examples\n- README.md: Updated API reference to show ?wait=N parameter"
    }
  ],
  "milestones": [],
  "questions": [],
  "considerations": {},
  "progress_log": [
    {
      "timestamp": "2026-01-24T19:55:36.235698+00:00",
      "message": "Plan created: Add long-polling support for inbox messages"
    },
    {
      "timestamp": "2026-01-24T19:56:11.626808+00:00",
      "message": "Updated context"
    },
    {
      "timestamp": "2026-01-24T19:56:35.253368+00:00",
      "message": "Updated approach"
    },
    {
      "timestamp": "2026-01-24T19:56:57.517695+00:00",
      "message": "Added 5 tasks"
    },
    {
      "timestamp": "2026-01-24T19:57:33.751139+00:00",
      "message": "Plan submitted for review"
    },
    {
      "timestamp": "2026-01-24T19:58:17.693717+00:00",
      "message": "Plan self-approved by agent"
    },
    {
      "timestamp": "2026-01-24T19:58:17.694811+00:00",
      "message": "Plan execution started"
    },
    {
      "timestamp": "2026-01-24T19:59:47.753339+00:00",
      "message": "Completed task f485e7a2: Added has_new_messages() function to db.py that uses COUNT query for efficient checking."
    },
    {
      "timestamp": "2026-01-24T20:00:04.087716+00:00",
      "message": "Verified task f485e7a2"
    },
    {
      "timestamp": "2026-01-24T20:03:19.865974+00:00",
      "message": "Completed task d2cfb2a3: Added `wait` query parameter (0-60 seconds) to GET /{ns}/inbox/{id} endpoint. Uses async polling loop with 500ms intervals."
    },
    {
      "timestamp": "2026-01-24T20:03:35.588550+00:00",
      "message": "Verified task d2cfb2a3"
    },
    {
      "timestamp": "2026-01-24T20:05:57.298925+00:00",
      "message": "Completed task 07fc4ccf: Added `wait` parameter to Backend.get_inbox() interface. LocalBackend and InMemoryBackend use time.sleep polling loop. RemoteBackend passes wait param to API with extended timeout."
    },
    {
      "timestamp": "2026-01-24T20:06:15.365197+00:00",
      "message": "Verified task 07fc4ccf"
    },
    {
      "timestamp": "2026-01-24T20:08:40.346571+00:00",
      "message": "Completed task 2ac9dedf: Added `wait` parameter to client.get_inbox(). Added convenience methods: wait_for_messages() and listen() generator."
    },
    {
      "timestamp": "2026-01-24T20:08:56.320140+00:00",
      "message": "Verified task 2ac9dedf"
    },
    {
      "timestamp": "2026-01-24T20:10:47.255096+00:00",
      "message": "Completed task 1405aa6b: Added Long-Polling section to README with API usage and Python library examples. Updated API reference to show wait parameter."
    },
    {
      "timestamp": "2026-01-24T20:11:03.279572+00:00",
      "message": "Verified task 1405aa6b"
    }
  ],
  "completion_notes": "",
  "metrics": {
    "definitions": [],
    "snapshots": [],
    "execution_started_at": "2026-01-24T19:58:17.695763+00:00",
    "baseline_input_tokens": 50,
    "baseline_output_tokens": 85305,
    "baseline_thinking_tokens": 0,
    "baseline_cached_tokens": 12460355,
    "baseline_cost_dollars": 22.71460875
  },
  "approval_policy": "interactive",
  "approval_mode": "agent"
}
-->